from random import randint
from typing import Optional

import msal
from pydantic import SecretStr, computed_field
from pydantic_settings import BaseSettings
import requests

# In order to write to table
# Set up security role at admin.powerplatform.microsoft.com - Environment - Settings -Security Roles
# Assign the role to svc_sipe account

# Important:
# Primary Column is NOT actual primary key - that's the autogenerated guid column <tablename>_baseid
# Had to add Alternate Key (make.powerapps - table - Schema - Keys)
#   Alternate key must be unique - will fail if duplicate values are found


class DataverseConfig(
    BaseSettings,
    validate_default=True,
    env_prefix="DATAVERSE_",
):

    tenant_id: str = "32669cd6-737f-4b39-8bdd-d6951120d3fc"
    client_id: str = "df37356e-3316-484a-b732-319b6b4ad464"
    org: str = "orgc1997c24"

    username: str = "svc_sipe"
    password: SecretStr

    @computed_field
    @property
    def api_url(self) -> str:
        return f"https://{self.org}.crm.dynamics.com/api/data/v9.2/"

    @computed_field
    @property
    def env_url(self) -> str:
        return f"https://{self.org}.crm.dynamics.com"

    @computed_field
    @property
    def authority(self) -> str:
        return f"https://login.microsoftonline.com/{self.tenant_id}"

    @computed_field
    @property
    def scope(self) -> str:
        return f"{self.env_url}/.default offline_access"


class DataverseRestClient:
    def __init__(self, config: DataverseConfig):
        self.config = config
        self.token = self._acquire_token()
        self.headers = {
            "Authorization": f"Bearer {self.token['access_token']}",
            "OData-MaxVersion": "4.0",
            "OData-Version": "4.0",
            "Accept": "application/json",
            "If-None-Match": None,
            "Content-Type": "application/json",
        }

    def _acquire_token(self):
        app = msal.PublicClientApplication(
            client_id=self.config.client_id,
            authority=self.config.authority,
            client_credential=None,
        )

        if not self.config.username.endswith("@alleninstitute.org"):
            username = self.config.username + "@alleninstitute.org"
        else:
            username = self.config.username

        token = app.acquire_token_by_username_password(
            username,
            self.config.password.get_secret_value(),
            scopes=[self.config.scope],
        )
        if "access_token" in token:
            return token
        else:
            raise ValueError(f"Error acquiring token")

    def _construct_url(self, table: str, entry_id: Optional[str | dict] = None) -> str:
        if entry_id is None:
            query = ""
        elif isinstance(entry_id, str):
            query = f"({entry_id})"
        elif isinstance(entry_id, dict):  # Can query by alternate key
            key = list(entry_id.keys())[0]
            value = list(entry_id.values())[0]
            if isinstance(value, str):
                value = f"'{value}'"  # strings must be formatted with single quotes
            query = f"({key}={value})"

        url = self.config.api_url + table + query
        return url

    def get_entry(self, table: str, id: str | dict) -> dict:
        url = self._construct_url(table, id)
        response = requests.get(url, headers=self.headers)
        if not response.status_code == 200:
            raise ValueError(f"Error fetching {table}: {response.status_code} {response.text}")
        return response.json()

    def add_entry(self, table: str, data: dict) -> dict:
        url = self._construct_url(table)
        response = requests.post(url, headers=self.headers, json=data)
        if not response.status_code == 200:
            raise ValueError(f"Error adding {table} entry: {response.status_code} {response.text}")
        return response.json()

    def update_entry(self, table: str, id: str | dict, update_data: dict) -> dict:
        url = self._construct_url(table, id)
        headers = self.headers | {"Prefer": "return=representation"}
        response = requests.patch(url, headers=headers, json=update_data)
        if not response.status_code == 200:
            raise ValueError(f"Error updating {table} entry with id {id}: {response.status_code} {response.text}")
        return response.json()


def example_using_dataverse_client():
    config = DataverseConfig()
    client = DataverseRestClient(config)

    mouse_table = "crb81_dim_mice_bases"
    mouse_id = "614174"
    mouse_guid = "fe057d74-8683-f011-b4cb-6045bd03524b"
    mouse = client.get_entry(mouse_table, {"crb81_mouse_id": mouse_id})
    print(mouse)
    mouse = client.get_entry(mouse_table, mouse_guid)
    print(mouse)

    updated_mouse = client.update_entry(
        mouse_table,
        {"crb81_mouse_id": mouse_id},
        {"crb81_full_genotype": "UpdatedGenotype_" + str(randint(1, 100))},
    )
    print(updated_mouse)


if __name__ == "__main__":
    example_using_dataverse_client()
 